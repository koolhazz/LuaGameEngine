#ifndef BOYAA_SOCKET_HANDLER_H_20110312
#define BOYAA_SOCKET_HANDLER_H_20110312

#include "PacketBase.h"
#include "wtypedef.h"
#include <stdint.h>

#ifdef TCP_BUFFER_SIZE
	#define RECV_BUFFER TCP_BUFFER_SIZE //4096
#else
	#define RECV_BUFFER 4096
#endif

#define CONNECTION_TYPE_CLIENT	0

class SocketHandler:public PacketParser<NETInputPacket>
{
public:
	SocketHandler();
	SocketHandler(int sockt_fd, bool parse_protocal = true, bool encrypt = true, int conn_type = 0);
	~SocketHandler();

public:
	int handle_read();
	int handle_output();
	int handle_close();

	int fd() { return m_sock_fd; }
	static void handle_timeout();
	
	void SetClosed(bool b) { m_is_closed = b; }
	bool IsServerClosed() { return m_is_closed;}

	int SendPacketVarErr(void);
	int OnParser(char *buf, int nLen);
	virtual int  OnPacketComplete(NETInputPacket *);

	void clean(bool IsClosefd);//Çå¿ÕÏà¹Ø×ÊÔ´
	void assign(int sockt_fd, bool parse_protocal = true, bool encrypt = true, int conn_type = 0); //ÖØĞÂ¹ØÁª
public:
	static BYTE	m_SendByteMap[256];		//å­—èŠ‚æ˜ å°„è¡¨
	static BYTE	m_RecvByteMap[256];		//å­—èŠ‚æ˜ å°„è¡¨

	static WORD EncryptBuffer(NETOutputPacket *pPacket);
	static int  CrevasseBuffer(NETInputPacket *pPacket);

	static inline BYTE MapSendByte(BYTE const cbData) { BYTE cbMap = m_SendByteMap[cbData]; return cbMap; }
	static inline BYTE MapRecvByte(BYTE const cbData) { BYTE cbMap = m_RecvByteMap[cbData]; return cbMap; }
	
	int send_packet(NETOutputPacket *pPacket);
	void build_package(NETOutputPacket* pOutPack, short nCmdType, const char* pszFmt, ...);
private:
	int  m_sock_fd;
	char m_recvbuf[RECV_BUFFER];
	
	bool m_encrypt;
	bool m_parse_protocal;	//æ˜¯å¦ç”±Serverè§£æåè®®
	int  m_conn_flag;		//è¿æ¥æ ‡è¯†, é€šè¿‡flagæ¥åŒºåˆ«è¿æ¥ç±»å‹, å¦‚ä¸º0è¡¨ç¤ºå®¢æˆ·ç«¯è¿æ¥ï¼Œå¯ç”¨å…¶ä»–æ•°å­—åŒºåˆ«å¤§å…ï¼Œåç«¯è¿æ¥

	bool m_is_closed;
};

//é”çŠ²ç˜‘éç‰ˆåµ


#endif

